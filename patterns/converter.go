package patterns

import (
	"bytes"
	"fmt"
	"io"

	"github.com/gofrs/uuid"
	"gopkg.in/yaml.v2"
)

func manifestIsEmpty[K any](manifest map[string]K) bool {
	return len(manifest) == 0
}

func NewPatternFileFromK8sManifest(data []byte, ignoreErrors bool) (Pattern, error) {
	pattern := Pattern{
		Name:     "Autogenerated",
		Services: map[string]*Service{},
	}

	buffer := bytes.NewBuffer(data)
	decoder := yaml.NewDecoder(buffer)
	for {
		manifest := map[string]interface{}{}

		err := decoder.Decode(manifest)
		if err != nil {
			if err == io.EOF {
				if manifestIsEmpty(pattern.Services) {
					return pattern, ErrParseK8sManifest(fmt.Errorf("kubernetes manifest is empty"))
				}
				return pattern, nil
			} else {
				return pattern, ErrParseK8sManifest(fmt.Errorf("kubernetes manifest is empty"))
			}
		}
		if manifestIsEmpty(manifest) {
			continue
		}
		// Recursive casting
		manifest = RecursiveCastMapStringInterfaceToMapStringInterface(manifest)
		if manifest == nil {
			if ignoreErrors {
				continue
			}
			return pattern, ErrParseK8sManifest(fmt.Errorf("failed to parse manifest into an internal representation"))
		}

		name, svc, err := createPatternServiceFromK8s(manifest)
		if err != nil {
			if ignoreErrors {
				continue
			}
			return pattern, ErrCreatePatternService(fmt.Errorf("failed to create design service from kubernetes component: %s", err))
		}

		pattern.Services[name] = &svc
	}

}

func createPatternServiceFromK8s(manifest map[string]interface{}) (string, Service, error) {
	apiVersion, _ := manifest["apiVersion"].(string)
	kind, _ := manifest["kind"].(string)
	metadata, _ := manifest["metadata"].(map[string]interface{})
	name, _ := metadata["name"].(string)
	namespace, _ := metadata["namespace"].(string)
	labels, _ := metadata["labels"].(map[string]interface{})
	annotations, _ := metadata["annotations"].(map[string]interface{})
	if namespace == "" {
		namespace = "default"
	}
	fmt.Printf("%+#v\n", manifest)
	// rest will store a map of everything other than the above mentioned fields
	rest := map[string]interface{}{}
	for k, v := range manifest {
		// Ignore a few fields
		if k == "apiVersion" || k == "kind" || k == "metadata" || k == "status" {
			continue
		}

		rest[k] = v
	}

	id := name
	uid, err := uuid.NewV4()
	if err == nil {
		id = uid.String()
	}
	if apiVersion == "" || kind == "" {
		return "", Service{}, ErrCreatePatternService(fmt.Errorf("empty apiVersion or kind in manifest"))
	}

	// Setup labels
	castedLabel := map[string]string{}
	for k, v := range labels {
		cv, ok := v.(string)
		if ok {
			castedLabel[k] = cv
		}
	}

	// Setup annotations
	castedAnnotation := map[string]string{}
	for k, v := range annotations {
		cv, ok := v.(string)
		if ok {
			castedAnnotation[k] = cv
		}
	}
	// rest = Format.Prettify(rest, false) // ensure pattern is prettified when saved in server.
	uuidV4, _ := uuid.NewV4()
	svc := Service{
		Name:        name,
		Type:        kind,
		APIVersion:  apiVersion,
		Namespace:   namespace,
		Model:       "kubernetes",
		Labels:      castedLabel,
		Annotations: castedAnnotation,
		Settings:    rest,
		Traits: map[string]interface{}{
			"meshmap": map[string]interface{}{
				"id": uuidV4,
			},
		},
	}

	return id, svc, nil
}
